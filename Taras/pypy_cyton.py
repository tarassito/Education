# -*- coding: utf-8 -*-

# Python - це інтерфейс, який має багато імплементацій Cpython(С) (Jython(Java), IronPython(C#), Brython(JS)).
# Cpython  компілює пайтон код в байткод. Байткод запускається на віртуальній машині СPython.


# Pypy - заміна Cpython, написана на RPython(статично типізована підмножина пайтона)

# Pypy :
#  швидкий -  бо компілює початковий код в машинний(за допомогою  JIT). аналітика по статистиці http://speed.pypy.org
#  гнучкий - добавляє JIT в інтерпретатор без певних зусиль.


# JIT (Just-in-Time Compilation) - компілює частину байткода в машинний код. Машинний код (запускається безпосередньо
# процесором) швидший за байткод.
#  Приклад JIT підходу:
#  1. Найти байткод, який запускається часто
#  2. Скомпілювати його в машинний код
#  3. Закешувати результат
#  4. Коли треба запустити, той самий байткод, використовувати вже скомпільованний машинний.

l=0
for i in xrange(1,10000):
    for ii in xrange(1, 10000):
        l += i+ii
print(l)


# Недостатки PyPy:
# Довгий час "розігріву" (якщо програма менше ніж секунду, то JIT не встигне розігнатися)
# повільніше працює import
# деколи повільніше працюють run-time і sdtlib
# не всі С-extentions працюють в Pypy. (CPython API, NumPy, SciPym, psycopg2)

# l=0
# for i in xrange(1,10000):
#     l += i
# print(l)


# Cython - спеціальна мова , яка дозволяє всередині звичайного пайтона кода вставляти Cython код
# (визначаєш типи данних, можна викликати C функції)
#  Ціль - дозволити писати С-екстеншн на пайтоні.
#  Дозволяє компілятору генерувати С код з Сython.
#  Дозволяє добавити статичну типізацію в пайтон код, яка після повторної компіляції може допомогти
#  досягти продуктивності як на С. Легко відключається GIL
#  Схоже на PyPy , але в PyPy пишеш звичайний Python код.


# def looper(n):
#     k = 0
#     for i in range(n):
#         for j in range(n):
#             k += j
#     return k
#
#
# import cython
# cimport cython
#
# cpdef long looper(int n):
#     cdef long i, j, k = 0
#     for i in range(n):
#         for j in range(n):
#             k += j
#     return k
#
